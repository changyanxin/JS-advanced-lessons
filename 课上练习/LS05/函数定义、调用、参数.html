<!DOCTYPE html>
<head>
	<meta charst="UTF-8"/>
	<title>函数的定义、调用、参数</title>
</head>
<body>
</body>
<script>
	//函数声明的方式定义函数
	sum(1,2);
	//变量的定义会进行变量提升
	function sum(x,y){
		return x+y;
	}
	//sum(1,2);

	//函数表达式可以是匿名函数
	window.onload=function(){
		alert("页面加载完成");
	}

	//函数表达式
	var sum1 = function(x,y){
		return x+y;
	}
	sum1(1,2);

	//使用new一个Function构造一个function函数，执行效率较低，较为灵活
	var sum2 = new Function('x','y','return x + y');

	



	//函数调用的四种方式,this的指向
	//1. 作为函数直接调用（严格模式下this指向undefined，非严格模式下this指向window）
	//2. 作为方法调用，this指向此方法的对象
	var obj={
		x:0,
		test:function(){
			console.log(this.x)
		}
	}
	obj.test();
	//3. 通过call()和apply()间接调用(this函数对象的call(),apply()方法的首个参数)
	//call(对象)可以切换方法的调用对象
	var objA={"objName":"AAA"};
	var objB={"objName":"BBB"};
	objA.foo=function(){
		console.log(this.objName);
	}
	objA.foo();
	objA.foo.call(objB);//函数本来定义在objA上，也可以由objB调用
	//4. 构造函数的调用(this指向实例化出来的对象)
	function Person(userName){
		this.userName = userName;
}
	Person.prototype.sayHi = function(){
		console.log(this.userName);
	}
	var person = new Person("zhangsan");
	console.log(person._proto_ === Person.prototype);


	//实参>形参  arguments获取的是函数传入的实参，是一个类数组对象
	function test(){
		var s = "";
		for(var i = 0; i < arguments.length; i++){
			s += arguments[i];
		}
		return s;
	}
	test("hello","world","!");
	//实参<形参 少的为undefined

	//实参为基本数据类型时，形参改变不影响实参
	var a=2;
	function foo(x){
		x=1;
		console.log(a,x);//2,1
	}
	foo(2);
	console.log(a);//2
	//实参为引用数据类型时,形参改变影响实参
	var obj={x:0};
	function bar(obj1){
		obj1.x = 2;
		console.log(obj,obj1);
	}
	bar(obj);
</script>
</html>